/*
 * NAME                     : Dima Mukhin
 * STUDENT NUMBER           : 7773184
 * COURSE                   : COMP 3430
 * INSTRUCTOR               : Dr. Jim Young
 * ASSIGNMENT               : 3
 * Question                 : 1
 *
 */

/*
 * FILE     : main.c
 * REMARKS  : Handles the following commands: info, dir, cd, get
              Contains main function for running the fat32 reader
 *            Ussage: fat32reader /dev/somedevice
 */

#define _FILE_OFFSET_BITS 64
 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <ctype.h>

#include "fat32.h"
#include "bootsector.h"
#include "directoryentry.h"
#include "bootsector.h"
#include "errorcheck.h"

#define END_OF_CLUSTER 0x0FFFFFF8   // end of cluster signature
#define MAX_INPUT_SIZE 50           // maximum input to process
#define BYTETOMEG 1000000           // using this instead of 1048576 (same as in the example)
#define MEGTOBYTE 1000              // converting MB to GB
#define END_OF_READ 0               // EOF value of write() according to man page
#define CLUSTER_HI_OFFSET 16        // offset of cluster high

/*** private functions ***/
void showInfo();                                        // show FAT32 info
void showDir();                                         // show current directory
void changeDirectory(char dirName[]);                   // change directory
void getFile(char fileName[]);                          // get file by name
int dirNameEquals(char dirName[], char cdName[]);       // check if two dir names are equal
int fileNameEquals(char fileName[], char getName[]);    // check if two file names are equal
uint32_t getInputFromUser(char dest[]);                 // get input from user, max 50 chars
void processInput(char input[]);                        // process user input
void toUpperString(char *input);                        // convert input to upper case

// populate a file from the device to local machine
void populateFile(uint32_t startCluster, uint32_t fileFD, uint32_t fileSize);


/*** private global variables ***/
int retVal;         // return value for error checking
fat32 *fat32Obj;    // fat32 file system of the current device

int main(int argc, char* argv[])
{
    // checking ussage
    if (argc < 2)
    {
        printf("Ussage: fat32reader /dev/somedevice\nExiting program\n");
        exit(EXIT_FAILURE); 
    }   
    
    uint32_t deviceFP = open(argv[1], O_RDONLY);
    if (deviceFP == -1)
    {
        printf("could not open device correctly\nExiting program\n");
        exit(EXIT_FAILURE); 
    }
    
    // creating fat32 object for handling of the device (fat32 storage device)
    fat32Obj = createFat32(deviceFP);
    
    // signature checking and more
    char input[MAX_INPUT_SIZE];
    if (!checkFat32(fat32Obj))
    {
        printf("device was not loaded correctly\nplease try re-plugging the device\n");
        printf("would you like to continue anyways? (y/n)\n");
        fflush(stdout);
        getInputFromUser(input);
        if (input[0] == 'n')
            exit(EXIT_FAILURE);
    }
    
    // getting input from user and processing it
    while (getInputFromUser(input) != END_OF_READ)
    {
        processInput(input);
    }
    
    // when EOF detected, close the device, clean-up, and exit
    freeFat32(fat32Obj);
    close(deviceFP);
    printf("Exiting program...\n");
    return 0;
}

/*---------------------------------------------------------------------------------getInputFromUser
 * Getting input from user and storing it in "dest"
 * returns the amount of bytes read or 0 on EOF
 */
uint32_t getInputFromUser(char dest[])
{
    uint32_t readVal;
    
    memset(dest, 0, MAX_INPUT_SIZE);
    retVal = write(STDOUT_FILENO, "> ", 2);
    checkForError(retVal, ERR_WRITE_MSG);
    readVal = read(STDIN_FILENO, dest, MAX_INPUT_SIZE);
    checkForError(readVal, ERR_READ_MSG);
    if (strlen(dest) > 0)
        dest[strlen(dest) - 1] = '\0';
    
    return readVal;
}// getInputFromUser

/*-------------------------------------------------------------------------------------processInput
 * Process input from user and initialize appropriate command
 * prints a message on invalid input
 */
void processInput(char input[])
{
    char delim[2] = " ";
    char *token;
    
    token = strtok(input, delim);
    if (token == NULL || strlen(token) <= 0)
        return;
    
    if (strcmp(token, "info") == 0)
        showInfo();
    else if (strcmp(token, "dir") == 0)
        showDir();
    else if (strcmp(token, "cd") == 0)
    {
        token = strtok(NULL, delim);
        if (token != NULL)
        {
            toUpperString(token);
            changeDirectory(token);
        }
    }
    else if (strcmp(token, "get") == 0)
    {
        token = strtok(NULL, delim);
        if (token != NULL)
        {
            toUpperString(token);
            getFile(token);
        }
    }
    else
    {
        printf("\nCommand not found\n");
    }
}// processInput

/*-----------------------------------------------------------------------------------------showInfo
 * Show the info of the boot sector
 */
void showInfo()
{
    fat32BS *bootSector = fat32Obj->bootSector;
    uint64_t sizeInBytes = getSizeInBytes(bootSector);
    uint64_t sizeInMB = sizeInBytes / BYTETOMEG;
    double sizeInGB = ((double) sizeInMB) / MEGTOBYTE;
    
    printf("\n---- Device Info ----\n");
    printf("OEM Name: %.*s\n", BS_OEMName_LENGTH, bootSector->BS_OEMName);
    printf("Label: %.*s\n", BS_VolLab_LENGTH, bootSector->BS_VolLab);
    printf("File System Type: %.*s\n", BS_FilSysType_LENGTH, bootSector->BS_FilSysType);
    printf("Media Type: %#X (%s)\n", bootSector->BPB_Media, getMediaType(bootSector));
    printf("Size: %lu (%luMB, %.2fGB)\n", sizeInBytes, sizeInMB, sizeInGB);
    printf("Drive Number: %d (%s)\n", bootSector->BS_DrvNum, getDriveType(bootSector));
    
    printf("\n--- Geometry ---\n");
    printf("Bytes per Sector: %d\n", bootSector->BPB_BytesPerSec);
    printf("Sectors per Cluster: %d\n", bootSector->BPB_SecPerClus);
    printf("Total Sectors: %d\n", bootSector->BPB_TotSec32);
    
    printf("\n--- FS Info ---\n");
    printf("Volume ID: %.*s\n", BS_VolLab_LENGTH, bootSector->BS_VolLab);
    printf("Version: %d:%d\n", bootSector->BPB_FSVerHigh, bootSector->BPB_FSVerLow);
    printf("Reserved Sectors: %d\n", bootSector->BPB_RsvdSecCnt);
    printf("Number of FATs: %d\n", bootSector->BPB_NumFATs);
    printf("FAT Size: %d sectors\n", bootSector->BPB_FATSz32);
    printf("Mirrored FAT: %d (%s)\n", getMirrFatVal(bootSector), getMirrFatMsg(bootSector));
}// showInfo

/*------------------------------------------------------------------------------------------showDir
 * show dirrectory information of the current directory pointed by fat32Obj
 * NOTE: body of dir search differs from other functions
 */
void showDir()
{
    fat32DE *currDir = fat32Obj->directoryEntry;
    char clusterBuffer[fat32Obj->clusterSize]; // buffer for current dir cluster
    uint32_t curEntry = 0; // current entry in cluster (make sure we dont step out of cluster)
    uint32_t curClust = fat32Obj->curDirCluster; // current cluster of the directory
    uint32_t dirsPerClust = fat32Obj->clusterSize / sizeof(fat32DE); // directories per cluster
    
    printf("\nDIRECTORY LISTING\n");
    printf("VOL_ID: %.*s\n\n", BS_VolLab_LENGTH, fat32Obj->bootSector->BS_VolLab);
    
    // while there are still more entries in the directory
    while (currDir->DIR_Name[0] != (char)END_ENTRY)
    {
        // handle directory entry display
        if (currDir->DIR_Name[0] != (char)FREE_ENTRY && currDir->DIR_FileSize != -1)
        {
            if (currDir->DIR_Attr & (uint8_t)ATTR_DIRECTORY)
                printf("<%.*s>\t%d\n", getDirNameSize(currDir), 
                currDir->DIR_Name, currDir->DIR_FileSize);
            else if (currDir->DIR_Attr != (uint8_t)ATTR_LONG_NAME &&
                currDir->DIR_Attr != (uint8_t)ATTR_VOLUME_ID)
                printf("%.*s\t%d\n", DIR_Name_LENGTH, currDir->DIR_Name, currDir->DIR_FileSize);
        }
        
        // handle directory cluster traversal
        curEntry++;
        currDir++;
        if (currDir->DIR_Name[0] == (char)END_ENTRY || curEntry >= dirsPerClust)
        {
            curClust = readFAT(fat32Obj, curClust);
            if (curClust < (uint32_t)END_OF_CLUSTER && curClust != 0)
            {
                curEntry = 0;
                readCluster(fat32Obj, curClust, clusterBuffer);
                currDir = (fat32DE*) clusterBuffer;
            }
        }
    }
    
    printf("--Bytes Free: %lu\n", getFreeBytes(fat32Obj));
    printf("--DONE\n");
}// showDir

/*----------------------------------------------------------------------------------changeDirectory
 * change directory to specified directory (by directory name)
 * NOTE: body of dir search differs from other functions
 */
void changeDirectory(char dirName[])
{
    fat32DE *currDir = fat32Obj->directoryEntry;
    char clusterBuffer[fat32Obj->clusterSize]; // buffer for current dir cluster
    uint32_t curClust = fat32Obj->curDirCluster; // current cluster of the directory
    uint32_t curEntry = 0; // current entry in cluster (make sure we dont step out of cluster)
    uint32_t dirsPerClust = fat32Obj->clusterSize / sizeof(currDir); // directories per cluster
    
    // while there are still more entries in the directory
    while (currDir->DIR_Name[0] != (char)END_ENTRY)
    {
        // handle directory transition
        if (currDir->DIR_Name[0] != (char)FREE_ENTRY && currDir->DIR_Attr & (char)ATTR_DIRECTORY)
        {
            if (dirNameEquals(currDir->DIR_Name, dirName))
            {
                uint32_t clusterNum = currDir->DIR_FstClusLO +
                (currDir->DIR_FstClusHI << CLUSTER_HI_OFFSET);
                readCluster(fat32Obj, clusterNum, fat32Obj->dirClusterBuf);
                if (clusterNum == 0)
                    fat32Obj->curDirCluster = fat32Obj->bootSector->BPB_RootClus;
                else
                    fat32Obj->curDirCluster = clusterNum;
                fat32Obj->directoryEntry = (fat32DE*) fat32Obj->dirClusterBuf;
                return;
            }
        }
        
        // if directory was not yet found, try moving to the next cluster
        curEntry++;
        currDir++;
        if (currDir->DIR_Name[0] == (char)END_ENTRY || curEntry >= dirsPerClust)
        {
            curClust = readFAT(fat32Obj, curClust);
            if (curClust < (uint32_t)END_OF_CLUSTER && curClust != 0)
            {
                curEntry = 0;
                readCluster(fat32Obj, curClust, clusterBuffer);
                currDir = (fat32DE*) clusterBuffer;
            }
        }
    }
    
    printf("\nError: folder not found\n");
}// changeDirectory

/*------------------------------------------------------------------------------------------getFile
 * get file by name (put file on local machine)
 * NOTE: body of dir search differs from other functions
 */
void getFile(char fileName[])
{
    fat32DE *currDir = fat32Obj->directoryEntry;
    char clusterBuffer[fat32Obj->clusterSize]; // buffer for current dir cluster
    uint32_t curClust = fat32Obj->curDirCluster; // current cluster of the directory
    uint32_t curEntry = 0; // current entry in cluster (make sure we dont step out of cluster)
    uint32_t dirsPerClust = fat32Obj->clusterSize / sizeof(currDir); // directories per cluster
    
    // while there are still more entries in the directory
    while (currDir->DIR_Name[0] != (char)END_ENTRY)
    {
        // check the file name and get it
        if (currDir->DIR_Name[0] != (char)FREE_ENTRY && currDir->DIR_FileSize != -1)
        {
            if (fileNameEquals(currDir->DIR_Name, fileName))
            {
                uint32_t clusterNum = currDir->DIR_FstClusLO + 
                (currDir->DIR_FstClusHI << CLUSTER_HI_OFFSET);
                int fileFD = open(fileName, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);
                populateFile(clusterNum, fileFD, currDir->DIR_FileSize);
                close(fileFD);
                return;
            }
        }
        
        // if the file was not yet found, try searching in the next cluster (if exists)
        curEntry++;
        currDir++;
        if (currDir->DIR_Name[0] == (char)END_ENTRY || curEntry >= dirsPerClust)
        {
            curClust = readFAT(fat32Obj, curClust);
            if (curClust < (uint32_t)END_OF_CLUSTER && curClust != 0)
            {
                curEntry = 0;
                readCluster(fat32Obj, curClust, clusterBuffer);
                currDir = (fat32DE*) clusterBuffer;
            }
        }
    }
    
    printf("\nError: file not found\n");
}// getFile

/*------------------------------------------------------------------------------------dirNameEquals
 * compares directory name (fat32 format) to user entered name
 */
int dirNameEquals(char dirName[], char cdName[])
{
    if (strlen(cdName) > DIR_LENGTH)
        return 0;
    
    for (int i = 0; i < strlen(cdName); i++)
    {
        if (dirName[i] != cdName[i])
            return 0;
    }
    
    if (strlen(cdName) < DIR_LENGTH && dirName[strlen(cdName)] != (char)DIR_PAD)
        return 0;
    
    return 1;
}// dirNameEquals

/*-----------------------------------------------------------------------------------fileNameEquals
 * compares file name (fat32 format) to user input file name
 */
int fileNameEquals(char fileName[], char getName[])
{
    int getNamePtr = 0;
    int fileNamePtr = 0;
    
    while (getNamePtr < strlen(getName) || fileNamePtr < DIR_Name_LENGTH)
    {
        if (getName[getNamePtr] == '.')
            getNamePtr++;
        else if (fileName[fileNamePtr] == (char)DIR_PAD)
            fileNamePtr++;
        else if (getName[getNamePtr] != fileName[fileNamePtr])
            return 0;
        else
        {
            if (getNamePtr < strlen(getName))
                getNamePtr++;
            if (fileNamePtr < DIR_Name_LENGTH)
                fileNamePtr++;
        }
    }
    
    return 1;
}// fileNameEquals

/*-----------------------------------------------------------------------------------------populateFile
 * populate an existing local file from a device
 * Note: specify a file by its starting cluster number on the device ("startCluster")
 */
void populateFile(uint32_t startCluster, uint32_t fileFD, uint32_t fileSize)
{
    uint32_t currCluster = startCluster;
    uint32_t nextCluster;
    uint32_t lastClusterSize = fileSize % fat32Obj->clusterSize;
    
    printf("\nGetting file, please wait...\n");
    
    while (currCluster < (uint32_t)END_OF_CLUSTER && currCluster != 0)
    {
        readCluster(fat32Obj, currCluster, fat32Obj->fileClusterBuf);
        nextCluster = readFAT(fat32Obj, currCluster);
        
        // if we are on the last cluster, only copy the reminder
        if (nextCluster >= (uint32_t)END_OF_CLUSTER)
            retVal = write(fileFD, fat32Obj->fileClusterBuf, lastClusterSize);
        else
            retVal = write(fileFD, fat32Obj->fileClusterBuf, fat32Obj->clusterSize);
        
        checkForError(retVal, ERR_WRITE_MSG);
        currCluster = nextCluster;
    }
    
    printf("\nDone.\n");
}// populateFile

/*------------------------------------------------------------------------------------toUpperString
 * convert string into upper case
 */
void toUpperString(char *input)
{
    for (int i = 0; i < strlen(input); i++)
        input[i] = toupper(input[i]);
}// toUpperString

/*
 * FILE     : fat32.h
 * REMARKS  : header file of fat32.c
 */

#ifndef FAT32_H
#define FAT32_H

#include <inttypes.h>

#include "bootsector.h"
#include "directoryentry.h"
#include "fsinfo.h"

#define BYTE_SIZE 8

/* Fat32 Datastructure
 * Used for storing Fat32 file system information
 */
typedef struct fat32_struct
{
    uint32_t deviceFP;
    uint32_t cluster2;
    uint32_t sectorSize;
    uint32_t clusterSize;
    uint32_t curDirCluster;
    char *dirClusterBuf;
    char *fatSectorBuf;
    char *fileClusterBuf;
    fat32BS *bootSector;
    fat32DE *directoryEntry;
    fat32FI *fsinfo;
} fat32;

/*** public functions ***/

// create FAT32 structure for a device
fat32* createFat32(uint32_t deviceFP);

// read a cluster from fat device into a buffer
void readCluster(fat32 *fat32Obj, uint64_t clusterNum, char buf[]);

// read file allocation table entry n, return its entry
uint32_t readFAT(fat32 *fat32Obj, uint32_t n);

// read a sector from fat device into a buffer
void readSector(fat32 *fat32Obj, uint64_t sectorNum, char buf[]);

// make sure device was loaded correctly
int checkFat32(fat32 *fat32Obj);

// get amount of free bytes from device
uint64_t getFreeBytes(fat32 *fat32Obj);

// free all allocated memory
void freeFat32(fat32 *fat32Obj);

#endif

/*
 * FILE     : fat32.c
 * REMARKS  : everything fat32
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#include "fat32.h"
#include "bootsector.h"
#include "errorcheck.h"
    
#define BYTES_PER_32BIT 4           // used for FAT entry calculation (bytes per 32 bit)
#define BYTE_OFFSET 8               // byte offset
#define DBYTE_OFFSET 16             // double byte offset (used for constructing fat entry)
#define TBYTE_OFFSET 24             // triple byte offset
#define FAT_MASK 0x0FFFFFFF         // fat mask (according to white pages)
#define FAT12_CLUSTERS 4085         // max fat12 clusters (according to white pages)
#define FAT16_CLUSTERS 65525        // max fat16 clusters (according to white pages)
#define FAT0_VALID_MASK 0x0FFFFF00  // fat entry 0 signature validation mask
#define ClnShutBitMask 0x08000000   // clean/dirty bit of fat entry 2
#define HrdErrBitMask 0x04000000    // read/write err bit of fat entry 2
#define EOC 0x0FFFFFFF              // End of clusterchain

/*** private function declerations ***/
int isFat32Valid(fat32 *fat32Obj);
int isFileAllocationTableValid(fat32 *fat32Obj);

/*** private global variables ***/
int retVal; // return value for error checking

/*** public functions region ***/

/*--------------------------------------------------------------------------------------createFat32
 * create a fat32 object to handle a device
 * stores all important information like bootsector, FSinfo, and more
 * can be used for multiple different devices at the same time
 */
fat32* createFat32(uint32_t deviceFP)
{
    fat32 *fat32Obj = (fat32*) malloc(sizeof(fat32));
    fat32Obj->deviceFP = deviceFP;
    
    // initializing the bootsector
    fat32Obj->bootSector = initializeBootSector(deviceFP);
    fat32BS *bootSector = fat32Obj->bootSector;
    
    // calculating important sizes and locations
    fat32Obj->sectorSize = bootSector->BPB_BytesPerSec;
    fat32Obj->clusterSize = bootSector->BPB_SecPerClus * fat32Obj->sectorSize;
    fat32Obj->curDirCluster = bootSector->BPB_RootClus;
    fat32Obj->cluster2 = bootSector->BPB_RsvdSecCnt + 
        (bootSector->BPB_NumFATs * bootSector->BPB_FATSz32);
    
    // mallocing buffers for safety (dont want something to override memory region while reading)
    fat32Obj->dirClusterBuf = (char*) malloc(fat32Obj->clusterSize);
    fat32Obj->fatSectorBuf = (char*) malloc(fat32Obj->sectorSize);
    fat32Obj->fileClusterBuf = (char*) malloc(fat32Obj->clusterSize);
    
    // reading current directory cluster (root) and assigning current directory structure
    readCluster(fat32Obj, fat32Obj->curDirCluster, fat32Obj->dirClusterBuf);
    fat32Obj->directoryEntry = (fat32DE*) fat32Obj->dirClusterBuf;
    
    // getting FSinfo
    char tempSectorBuf[fat32Obj->sectorSize];
    readSector(fat32Obj, bootSector->BPB_FSInfo, tempSectorBuf);
    fat32Obj->fsinfo = (fat32FI*) malloc(sizeof(fat32FI));
    memcpy(fat32Obj->fsinfo, tempSectorBuf, fat32Obj->sectorSize);
    
    return fat32Obj;
}// createFat32

/*--------------------------------------------------------------------------------------readCluster
 * Read a cluster from fat32, assign data to "buf"
 */
void readCluster(fat32 *fat32Obj, uint64_t clusterNum, char buf[])
{
    // if cluster is 0, read root instead.
    if (clusterNum == 0)
        clusterNum = fat32Obj->bootSector->BPB_RootClus;
    
    uint64_t cluster2 = fat32Obj->cluster2;
    uint64_t cluster2InBytes = cluster2 * fat32Obj->sectorSize;
    uint64_t offsetInBytes = (clusterNum - 2) * fat32Obj->clusterSize;
    off_t totalOffset = cluster2InBytes + offsetInBytes;
    
    lseek(fat32Obj->deviceFP,  totalOffset, SEEK_SET);
    checkForError(totalOffset, ERR_LSEEK_MSG);
    
    retVal = read(fat32Obj->deviceFP, buf, fat32Obj->clusterSize);
    checkForError(retVal, ERR_READ_MSG);
}// readCluster

/*---------------------------------------------------------------------------------------readSector
 * Read a sector from fat32, assign data to "buf"
 */
void readSector(fat32 *fat32Obj, uint64_t sectorNum, char buf[])
{
    off_t seekOffset = ((off_t) sectorNum * fat32Obj->sectorSize);
    lseek(fat32Obj->deviceFP, seekOffset, SEEK_SET);
    checkForError(seekOffset, ERR_LSEEK_MSG);
    retVal = read(fat32Obj->deviceFP, buf, fat32Obj->sectorSize);
    checkForError(retVal, ERR_READ_MSG);
}// readSector

/*------------------------------------------------------------------------------------------readFAT
 * Read fat entry of a cluster
 * n: the cluster number
 */
uint32_t readFAT(fat32 *fat32Obj, uint32_t n)
{
    uint32_t fatEntry = -1;
    
    fat32BS *bootSector = fat32Obj->bootSector;
    uint64_t fatOffset = n * BYTES_PER_32BIT;
    uint64_t thisFATSecNum = bootSector->BPB_RsvdSecCnt + (fatOffset / bootSector->BPB_BytesPerSec);
    readSector(fat32Obj, thisFATSecNum, fat32Obj->fatSectorBuf);    
    uint64_t thisFATEntOffset = fatOffset % bootSector->BPB_BytesPerSec;
    fatEntry = (uint8_t) fat32Obj->fatSectorBuf[thisFATEntOffset] +
        ((uint8_t) fat32Obj->fatSectorBuf[thisFATEntOffset + 1] << BYTE_OFFSET) +
        ((uint8_t) fat32Obj->fatSectorBuf[thisFATEntOffset + 2] << DBYTE_OFFSET) +
        ((uint8_t) fat32Obj->fatSectorBuf[thisFATEntOffset + 3] << TBYTE_OFFSET);
    fatEntry = fatEntry & FAT_MASK; // ignoring first 4 bits
    
    return fatEntry;
}// readFAT

/*---------------------------------------------------------------------------------------checkFat32
 * Validate fat32 device was loaded correctly and that it is infact a fat32 device
 */
int checkFat32(fat32 *fat32Obj)
{
    // validate bootsector
    if (!isBootSectorValid(fat32Obj->bootSector))
    {
        printf("BootSector was not loaded correctly\n");
        return 0;
    }
    
    // validate fat is 32
    if (!isFat32Valid(fat32Obj))
        return 0;
    
    // validate the file allocation table
    if (!isFileAllocationTableValid(fat32Obj))
        return 0;
    
    // validate FS info
    if (!isFSinfoValid(fat32Obj->fsinfo))
    {
        printf("file system info was not loaded correctly\n");
        return 0;
    }
    
    return 1;
}// checkFat32

/*-------------------------------------------------------------------------------------getFreeBytes
 * calculate and return the number of free bytes
 */
uint64_t getFreeBytes(fat32 *fat32Obj)
{
    return fat32Obj->fsinfo->FSI_Free_Count * ((uint64_t) fat32Obj->clusterSize);
}// getFreeBytes

/*----------------------------------------------------------------------------------------freeFat32
 * free all allocated memory
 */
void freeFat32(fat32 *fat32Obj)
{
    free(fat32Obj->dirClusterBuf);
    free(fat32Obj->fatSectorBuf);
    free(fat32Obj->fileClusterBuf);
    free(fat32Obj->bootSector);
    free(fat32Obj->fsinfo);
    free(fat32Obj);
}// freeFat32

/*** private functions region ***/

/*-------------------------------------------------------------------------------------isFat32Valid
 * Make sure the device loaded is fat32, exit otherwise.
 */
int isFat32Valid(fat32 *fat32Obj)
{
    fat32BS* bootSector = fat32Obj->bootSector;
    
    uint32_t RootDirSectors = ((((uint32_t) bootSector->BPB_RootEntCnt) * BYTES_PER_DIR_ENT) + 
        (bootSector->BPB_BytesPerSec - 1));
        
    uint32_t FATSz;
    if(bootSector->BPB_FATSz16 != 0)
        FATSz = bootSector->BPB_FATSz16;
    else
        FATSz = bootSector->BPB_FATSz32;
    
    uint32_t TotSec;
    if(bootSector->BPB_TotSec16 != 0)
        TotSec = bootSector->BPB_TotSec16;
    else
        TotSec = bootSector->BPB_TotSec32;
    
    uint32_t DataSec = TotSec - (bootSector->BPB_RsvdSecCnt + 
        (((uint32_t)bootSector->BPB_NumFATs) * FATSz) + RootDirSectors);
    
    uint32_t CountofClusters = DataSec / ((uint32_t) bootSector->BPB_SecPerClus);
    
    if(CountofClusters < FAT12_CLUSTERS) 
    {
        printf("Error, volume is FAT12\n");
        return 0;
    } 
    else if(CountofClusters < FAT16_CLUSTERS) 
    {
        printf("Error, volume is FAT16\n");
        return 0;
    } 
    
    return 1;
}// isFat32Valid

/*-----------------------------------------------------------------------isFileAllocationTableValid
 * validate the first file allocation table of the device.
 * checks the first two entries of the file allocation table according
 * to the white pages. (see page 18)
 */
int isFileAllocationTableValid(fat32 *fat32Obj)
{
    uint32_t fat0signature = ((uint32_t)fat32Obj->bootSector->BPB_Media) | FAT0_VALID_MASK;
    if (readFAT(fat32Obj, 0) != fat0signature)
    {
        printf("Filed to validate fat entry 0\n");
        return 0;
    }
        
    // fat entry 1 with maksked out dirty bit and read/write error bit (according to white pages)
    uint32_t fat1masked = readFAT(fat32Obj, 1) | ClnShutBitMask | HrdErrBitMask;
    
    uint32_t fat1signature = EOC;
    if (fat1masked != fat1signature)
    {
        printf("Filed to validate fat entry 1\n");
        return 0;
    }
        
    return 1;
}// isFileAllocationTableValid

/*
 * FILE     : bootsector.h
 * REMARKS  : header file of bootsector.h
 */

#ifndef BOOTSECTOR_H
#define BOOTSECTOR_H

#include <inttypes.h>

/*         boot sector constants         */
/* Data structure provided by assignment */
#define BS_OEMName_LENGTH 8     // length of BS_OEMName
#define BS_VolLab_LENGTH 11     // length of BS_VolLab
#define BS_FilSysType_LENGTH 8  // length BS_FilSysType_LENGTH

#pragma pack(push)
#pragma pack(1)
struct fat32BS_struct {
    char BS_jmpBoot[3];
    char BS_OEMName[BS_OEMName_LENGTH];
    uint16_t BPB_BytesPerSec;
    uint8_t BPB_SecPerClus;
    uint16_t BPB_RsvdSecCnt;
    uint8_t BPB_NumFATs;
    uint16_t BPB_RootEntCnt;
    uint16_t BPB_TotSec16;
    uint8_t BPB_Media;
    uint16_t BPB_FATSz16;
    uint16_t BPB_SecPerTrk;
    uint16_t BPB_NumHeads;
    uint32_t BPB_HiddSec;
    uint32_t BPB_TotSec32;
    uint32_t BPB_FATSz32;
    uint16_t BPB_ExtFlags;
    uint8_t BPB_FSVerLow;
    uint8_t BPB_FSVerHigh;
    uint32_t BPB_RootClus;
    uint16_t BPB_FSInfo;
    uint16_t BPB_BkBootSec;
    char BPB_reserved[12];
    uint8_t BS_DrvNum;
    uint8_t BS_Reserved1;
    uint8_t BS_BootSig;
    uint32_t BS_VolID;
    char BS_VolLab[BS_VolLab_LENGTH];
    char BS_FilSysType[BS_FilSysType_LENGTH];
    char BS_CodeReserved[420];
    uint8_t BS_SigA;
    uint8_t BS_SigB;
};
#pragma pack(pop)

typedef struct fat32BS_struct fat32BS;

/*** public functions ***/

// initialize the boot sector of the device
fat32BS* initializeBootSector(uint32_t deviceFP);

// get mirrored fat value
uint32_t getMirrFatVal(fat32BS *bootSector);

// signature validation of the boot sector 
int isBootSectorValid(fat32BS *bootSector);

// get mefia type (removable/fixed)
char* getMediaType(fat32BS *bootSector);

// get drive type (HD/floppy)
char* getDriveType(fat32BS *bootSector);

// is fat mirrored?
char* getMirrFatMsg(fat32BS *bootSector);

// get storage size in bytes
uint64_t getSizeInBytes(fat32BS *bootSector);

#endif

/*
 * FILE     : bootsector.c
 * REMARKS  : boot sector data structure implementation
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#include "bootsector.h"
#include "errorcheck.h"

#define BOOTSECTOR_SIZE 512     // boot sector size, not sector size
#define FAT32SIG 0x29           // fat32 bootsector signature
#define FIXED_MEDIA_TYPE 0xF8   // fixed media type signature bytes
#define DRV_NUM_HD 0x80         // HD type signature bytes
#define MIRR_FAT_MASK 0x0080    // mirrored FAT mask

/*** private variables ***/
char buf[BOOTSECTOR_SIZE];
int retVal;

/*** public functions ***/

/*-----------------------------------------------------------------------------initializeBootSector
 * Initialize the boot sector of the device and return it
 */
fat32BS* initializeBootSector(uint32_t deviceFP)
{
    retVal = read(deviceFP, buf, BOOTSECTOR_SIZE);
    checkForError(retVal, ERR_READ_MSG);
    fat32BS *bootSector = (fat32BS*) malloc(sizeof(fat32BS));
    memcpy(bootSector, buf, sizeof(*bootSector));
    return bootSector;
}// initializeBootSector

/*-------------------------------------------------------------------------------------getMediaType
 * get mefia type (removable/fixed)
 */
char* getMediaType(fat32BS *bootSector)
{
    if (bootSector->BPB_Media == (uint8_t)FIXED_MEDIA_TYPE)
        return "fixed";
    else
        return "removable";
}// getMediaType

/*-------------------------------------------------------------------------------------getDriveType
 * get drive type (HD/floppy)
 */
char* getDriveType(fat32BS *bootSector)
{
    if (bootSector->BS_DrvNum == (uint8_t)DRV_NUM_HD)
        return "HD";
    else
        return "floppy";
}// getDriveType

/*-------------------------------------------------------------------------------------getDriveType
 * get mirrored fat value
 */
uint32_t getMirrFatVal(fat32BS *bootSector)
{
    return ((uint32_t) (bootSector->BPB_ExtFlags & MIRR_FAT_MASK));
}// getDriveType

/*--------------------------------------------------------------------------------isBootSectorValid
 * signature validation of the boot sector
 */
int isBootSectorValid(fat32BS *bootSector)
{
    if (bootSector->BS_BootSig == (uint8_t)FAT32SIG)
        return 1;
    return 0;
}// isBootSectorValid

/*------------------------------------------------------------------------------------getMirrFatMsg
 * is fat mirrored?
 */
char* getMirrFatMsg(fat32BS *bootSector)
{
    if (getMirrFatVal(bootSector) == 0)
        return "yes";
    else
        return "no";
}// getMirrFatMsg

/*-----------------------------------------------------------------------------------getSizeInBytes
 * get storage size in bytes
 */
uint64_t getSizeInBytes(fat32BS *bootSector)
{
    return ((uint64_t) bootSector->BPB_TotSec32) * bootSector->BPB_BytesPerSec;
}// getSizeInBytes

/*
 * FILE     : directoryentry.h
 * REMARKS  : header file of directoryentry.c
 */

#ifndef DIRECTORYENTRY_H
#define DIRECTORYENTRY_H

#include <inttypes.h>

/* Directory Entry constants */
#define DIR_Name_LENGTH 11      // length of DIR_Name
#define DIR_LENGTH 8            // max length of file name (not including extension)
#define DIR_PAD 0x20            // padding byte of DIR_Name
#define BYTES_PER_DIR_ENT 32    // directory entry structyre total bytes

#define ATTR_DIRECTORY 0x10     // attribute directory signature
#define ATTR_VOLUME_ID 0x08     // volume id directory signature
#define ATTR_LONG_NAME 0x0F     // long name directory signature
#define FREE_ENTRY 0xE5         // free entry directory signature
#define END_ENTRY 0x00          // end/last entry directory signature

#pragma pack(push)
#pragma pack(1)
struct fat32DE_struct {
    char DIR_Name[DIR_Name_LENGTH];
    uint8_t DIR_Attr;
    uint8_t DIR_NTRes;
    uint8_t DIR_CrtTimeTenth;
    uint16_t DIR_CrtTime;
    uint16_t DIR_CrtDate;
    uint16_t DIR_LstAccDate;
    uint16_t DIR_FstClusHI;
    uint16_t DIR_WrtTime;
    uint16_t DIR_WrtDate;
    uint16_t DIR_FstClusLO;
    uint32_t DIR_FileSize;
};
#pragma pack(pop)

typedef struct fat32DE_struct fat32DE;

/*** public functions ***/

// get the size of the name of the directory entry
uint32_t getDirNameSize(fat32DE *dir);

#endif

/*
 * FILE     : directoryentry.c
 * REMARKS  : directory entry data structure implementation
 */

#include "directoryentry.h"
#include "fat32.h"
#include "bootsector.h"

#define MAX_DIR_NAME_SIZE 8
#define NAME_PADDING 0x20

/*-----------------------------------------------------------------------------------getDirNameSize
 * get the size of the name of the directory entry
 * size is the number of characters not includding padding or extension
 */
uint32_t getDirNameSize(fat32DE *dir)
{
    uint32_t size = 0;
    
    for (int i = 0; i < MAX_DIR_NAME_SIZE; i++)
        if (dir->DIR_Name[i] != (char)NAME_PADDING)
            size++;
    
    return size;
}// getDirNameSize

/*
 * FILE     : fsinfo.h
 * REMARKS  : header file of fsinfo.c
 */

#ifndef FSINFO_H
#define FSINFO_H

#include <inttypes.h>

/* FSinfo constants */
#define RESERVED1_SIZE 480  // size of FSI_Reserved1
#define RESERVED2_SIZE 12   // size of FSI_Reserved2

#pragma pack(push)
#pragma pack(1)
struct fat32FI_struct {
    uint32_t FSI_LeadSig;
    char FSI_Reserved1[RESERVED1_SIZE];
    uint32_t FSI_StrucSig;
    uint32_t FSI_Free_Count;
    uint32_t FSI_Nxt_Free;
    char FSI_Reserved2[RESERVED2_SIZE];
    uint32_t FSI_TrailSig;
};
#pragma pack(pop)

typedef struct fat32FI_struct fat32FI;

/*** public functions ***/

// validation of the file system info structure
int isFSinfoValid(fat32FI *fsinfo);

#endif

/*
 * FILE     : fsinfo.c
 * REMARKS  : file system info data structure implementation
 */

#include <inttypes.h>

#include "fsinfo.h"

#define LEAD_SIG_VALID 0x41615252
#define TRAIL_SIG_VALID 0xAA550000

/*------------------------------------------------------------------------------------isFSinfoValid
 * validation of the file system info structure
 */
int isFSinfoValid(fat32FI *fsinfo)
{
    if (fsinfo->FSI_LeadSig == (uint32_t)LEAD_SIG_VALID &&
        fsinfo->FSI_TrailSig == (uint32_t)TRAIL_SIG_VALID)
        return 1;
    return 0;
}// isFSinfoValid

/*
 * FILE     : errorcheck.h
 * REMARKS  : public error checking file for code reusability across different files
 */

#ifndef ERRORCHECK_H
#define ERRORCHECK_H

/*** common error messages ***/

#define ERR_WRITE_MSG "write() failed"
#define ERR_READ_MSG "read() failed"
#define ERR_LSEEK_MSG "lseek() failed"

/*** public functions ***/

// check return value. print message and exit on error
void checkForError(int errVal, char *msg);

#endif

/*
 * FILE     : errorcheck.c
 * REMARKS  : public error checking file for code reusability across different files
 */

#include <stdio.h>
#include <stdlib.h>
 
#include "errorcheck.h"

/*------------------------------------------------------------------------------------checkForError
 * global error checking function for code reusability across different files
 */
void checkForError(int errVal, char *msg)
{
    if (errVal == -1)
    {
        perror(msg);
        exit(EXIT_FAILURE);
    }
}// checkForError